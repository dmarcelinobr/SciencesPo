% Generated by roxygen2 (4.0.2): do not edit by hand
\name{recode}
\alias{recode}
\title{Replace given values with new values, in a vector or factor
 Replace values with new values in a vector or factor. \emph{This is the same function as \code{mapvalues} in the \pkg{plyr} package}, though an enhancement was added; you can set a catch-all category using the \code{residual} option.
If \code{x} is a factor, the matching levels of the factor will be replaced with the new values.
I included it here, and renamed it to minimize conflicts between same-named functions in \pkg{dplyr} and \pkg{plyr}. The \pkg{car} package already has a function called \code{recode} that essentially does the same thing. It is meant to provide the untility of the RECODE statment of SPSS, however, I rather find its verbose a little fuzzy.}
\usage{
recode(x, from, to, residual = NULL, warn = TRUE)
}
\arguments{
\item{x}{the factor or vector to modify}

\item{from}{a vector of the items to replace}

\item{to}{a vector of replacement values}

\item{residual}{a value to replace all the remaining values}

\item{warn}{print a message if any of the old values are not actually present in \code{x}}
}
\description{
Replace given values with new values, in a vector or factor
 Replace values with new values in a vector or factor. \emph{This is the same function as \code{mapvalues} in the \pkg{plyr} package}, though an enhancement was added; you can set a catch-all category using the \code{residual} option.
If \code{x} is a factor, the matching levels of the factor will be replaced with the new values.
I included it here, and renamed it to minimize conflicts between same-named functions in \pkg{dplyr} and \pkg{plyr}. The \pkg{car} package already has a function called \code{recode} that essentially does the same thing. It is meant to provide the untility of the RECODE statment of SPSS, however, I rather find its verbose a little fuzzy.
}
\examples{
#' # On numeric vectors
y <- sample(10)
recode(y, from = c(1, 5, 9), to = c(10, 50, 90))
# On factors
z <- factor(c("a", "b", "d", "c", "a"))
recode(z, c("a", "c"), c("A", "C"))
recode(z, from="d", to = "10")

x = data.frame(var1 = c(0,0,1,1), var2 = c(0,1,0,1))
 x$new_vals <- recode(x$var1,from=c(0, 1), to = c(1, 0))
}
\seealso{
See \code{mapvalues} in \pkg{plyr} for the sister function, or \code{revalue} in \pkg{plyr}; do the same thing but with a single named vector rather than on two separate vectors.
}

