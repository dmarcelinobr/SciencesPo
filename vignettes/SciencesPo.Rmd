---
title: "Introduction to the SciencesPo Package"
author: "Daniel Marcelino"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    fig_width: 5
vignette: >
  %\VignetteIndexEntry{Introduction to SciencesPo}
  %\VignetteEngine{knitr::rmarkdown}
    \usepackage[T1]{fontenc}
     \usepackage[utf8]{inputenc}
---
  
  To call in the statistician after the experiment is done may be no more than asking him to perform a post-mortem examination: he may be able to say what the experiment died of. ~ Sir Ronald Aylmer Fisher
The plural of anecdote is not data. ~ Roger Brinner
The combination of some data and an aching desire for an answer does not ensure that a reasonable answer can be extracted from a given body of data. ~ John Tukey

# Overview
The **SciencesPo** package is meant to provide algorithms and functions for analyzing political behavior data, including measures of political fragmentation and seats allocation. In addition, it also offers built-in functions for descriptive statistics, tests, tables, and pre set publication-ready plots and themes for **ggplot2**, which will require only a minimum amount of fiddling with sizes and labels, etc. The package is intended to give students and postdocs an easy way of making the most of their data--usually small datasets. Although this package is available for the general public, it meets my personal needs and tastes. Yours may be different.

You can find the package source on [Github](https://github.com/danielmarcelino/SciencesPo), and you are welcome to contribute code via pull requests, or file feature requests and bug reports via [Github issues](https://github.com/danielmarcelino/SciencesPo/issues).

# Learning by doing
This vignette builds on the examples scattered through the package's manual available on [https://cran.r-project.org](https://cran.r-project.org/web/packages/SciencesPo/SciencesPo.pdf). This first example walks through setting up **SciencesPo** for conducting basic data analysis.


## Loading and Unloading *SciencesPo*
```{r echo=TRUE, message=FALSE, comment=NA}
library(SciencesPo)


## Do things 


detach("package:SciencesPo", unload=TRUE)


#You can also use the unloadNamespace command,

unloadNamespace("SciencesPo")

```


## Search results from help.search()
Here are some examples demonstrating the results of help.search(), or you can also use ?? to search for a string.

```{r echo=TRUE, message=FALSE}
help.search('bar.plot')


help.search('twoway', package = 'SciencesPo')
```


## Vignette and dataset lists
To see the existing vignettes, type: 
```{r echo=TRUE, message=FALSE}
vignette(package = "SciencesPo")
```

To see the collection of data included in the package, type:
```{r echo=TRUE, message=FALSE}
data(package = "SciencesPo")
```


## Example of printing objects
First we take a look at a quick example of printing some R objects in the R console:

Whenever you load the package, it will setup its own environment, including plotting themes. Thus, some objects may be printed differently with what you would have seen in a normal R console. To not use the default settings, one can use : 

## Exploratory data functions

### Computing the Skewness and Kurtosis of the Data
This function performs three types of skewness tests:
```{r echo=FALSE, message=FALSE}
require(SciencesPo)

set.seed(51)
 w <-sample(4,10, TRUE)
 x <- sample(10, 1000, replace=TRUE, prob=w)
 
skewness(x, type = 1);
kurtosis(x, type = 1);
skewness(x); # Type 2 is the default 
kurtosis(x); # Type 2 is the default 
skewness(x, type = 3);
kurtosis(x, type = 3);

```


### Standard Error and Confidence Interval

To demonstrate the output of these functions, below are the ages of the Presidents of the United States at the time of their inaugurations.

```{r pres-ages, echo=TRUE, message=FALSE, cache=TRUE}
pres =c(42,43,46,46,47,48,49,49,50,51,51,51,51,51,52,52,54,54,54,54,54,55,55,55,55,56,56,56,57,57,57,57,58,60,61,61,61,62,64,64,65,68,69)

ci(pres, level=.95) # confidence interval

ci(pres, level=.95)@mean # confidence interval

se(pres) # std. error
```


### Average Absolute Deviation and Winsorized Mean
```{r echo=FALSE, message=FALSE}
aad(pres) 


winsorize(pres)
```


# Data Manipulation


## `safe.chars`
By default, R converts character columns to factors. Instead of re-reading the data using \code{stringsAsFactors=FALSE}, the \code{\link{safe.chars}} function identifies which columns are currently factors, and convert them all to characters parsing the levels as strings.

```{r echo=FALSE, message=FALSE}
require(SciencesPo)
str(iris)

iris_2 = safe.chars(iris)

str(iris_2)
```


## `destring`
This function converts factor variables to numeric, much like the way Stata does.
```{r echo=TRUE, message=FALSE}
require(SciencesPo)

mylevels <- c('Strongly Disagree', 
              'Disagree', 
              'Neither', 
              'Agree', 
              'Strongly Agree')

myvar <- factor(sample(mylevels[1:5], 10, replace=TRUE))
```


As we can see, this vector is un(ordered) in a "strange" way so to reflect the meaning of the levels I've attributed:
```{r echo=TRUE, message=FALSE}
unclass(myvar) # testing the order
```

By `destring` this, we should get a numeric result with the same (un)order:
```{r echo=TRUE, message=FALSE}
destring(myvar) 
```

## `rounded`
It's rather common to use numbers without leading zeros. The `rounded` function does just that. Isn't fancy?

```{r echo=TRUE, message=FALSE}
 (x = seq(0, 1, by=.1))
 rounded(x) 
```


# Tables
There is a specific document covering one-way, two-way, and multiway tabulations with accompanying independent tests. 

To tabulate on variable's responses, simply:

```{r one-way, echo=TRUE, message=FALSE, comment=NA}
CrossTabs(titanic$SURVIVED) 
```

A more performant descriptive output can be obtained with the `Freq` command, which resembles the *SPSS* output. 

```{r Freq, eval=FALSE, echo=FALSE, message=FALSE, comment=NA}
Freq(titanic, SURVIVED) 
```

To add a second, for a cross-tabulation:

```{r two-way, echo=TRUE, message=FALSE}
CrossTabs(titanic$SEX, titanic$SURVIVED) 
```

To delete table entries that are less relevant, for instance, to delete expected frequency, `expected=FALSE`. 
```{r echo=TRUE, message=FALSE, comment=NA}
CrossTabs(titanic$SEX, titanic$SURVIVED, expected=FALSE) 
```

To add table entries that relevant, add `TRUE` to it, for instance: `row=TRUE`, `column=TRUE`, `total=TRUE` etc.

```{r echo=TRUE, message=FALSE, comment=NA}
CrossTabs(titanic$SEX, titanic$SURVIVED, expected=FALSE, row=TRUE, column=TRUE) 
```


The 'chisq=FALSE' argument refers to a Chi-Square test of Independence, To calculate the test, switch it to `TRUE`.

```{r chisq, echo=TRUE, message=FALSE, comment=NA}
CrossTabs(titanic$SEX, titanic$SURVIVED, expected=FALSE, chisq=TRUE) 
```



# Distributions 

## `uniform`


# Political Behavior Measures

## Political Diversity Indices

```{r politicalDiversity1, echo=TRUE, message=FALSE}
library("SciencesPo")

# The 1980 presidential election in the US (vote share):

(US1980 <- c("Democratic"=0.410, "Republican"=0.507,
              "Independent"=0.066, "Libertarian"=0.011,
              "Citizens"=0.003, "Others"=0.003));

politicalDiversity(US1980); # ENEP (laakso/taagepera) method 

politicalDiversity(US1980, index= "golosov");

politicalDiversity(US1980, index= "herfindahl");


```

Considers the following `data.frame` with electoral results for the 1999 election in Helsinki, the seats were allocated using both the Saint-Lague and the D'Hondt methods: 

```{r Helsinki-election, echo=TRUE, message=FALSE}
# Helsinki's 1999

Helsinki <- data.frame(votes = c(68885, 18343, 86448, 21982, 51587,
                                 27227, 8482, 7250, 365, 2734, 1925,
                                 475, 1693, 693, 308, 980, 560, 590, 185),
                       seats_SL=c(5, 1, 6, 1, 4, 2, 1, 0, 0, 0, 0, 0, 0, 0,
                                  0, 0, 0, 0, 0),
                       seats_DH=c(5, 1, 7, 1, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0,
                                  0, 0, 0, 0, 0))
```

```{r echo=TRUE, message=FALSE, comment=NA}
# politicalDiversity(Helsinki$votes); #ENEP Votes

politicalDiversity(Helsinki$seats_SL); #ENP for Saint-Lague

politicalDiversity(Helsinki$seats_DH); #ENP for D'Hondt
```

## Highest Averages Methods of Allocating Seats Proportionally

Now using data from 2014 Brazilian legislative elections, especifically from one district, let's compare the results between the D'Hondt,  Saint-Lague, and Hungtinton-Hill methods.

```{r Ceara-election, echo=TRUE, cache=TRUE}
# Results for the state legislative house of Ceara (2014):
Ceara <- c("PCdoB"=187906, "PDT"=326841,"PEN"=132531, "PMDB"=981096,
           "PRB"=2043217,"PSB"=15061, "PSC"=103679, "PSTU"=109830,
           "PTdoB"=213988, "PTC"=67145, "PTN"=278267)
```

The basic imputs for this class of functions are: 1) a list of parties, 2) a list of positive votes, and 3) a constant value for the number of seats to be returned. A numeric value (0~1) for the threshold is optional.

### d'Hondt

```{r highestAverages1, echo=TRUE, message=FALSE, comment=NA}
highestAverages(parties=names(Ceara), votes=Ceara,
                seats = 42, method = "dh") 
```

The d'Hondt method is only one way of allocating seats in party list systems. Other methods include the Saint-Lague, the modified Saint-Lague, the Danish version, Imperiali (do not to confuse with the Imperiali quota which is a Largest remainder method), and Hungtinton-Hill. 

### Saint-Lague

```{r echo=TRUE, message=FALSE, comment=NA}
highestAverages(parties=names(Ceara), votes=Ceara,
                seats = 42, method = "sl") 
```

### Modified Saint-Lague
How does the Sainte-Lague method compare to the modified Sainte-Lague one?

```{r echo=TRUE, message=FALSE, comment=NA}
highestAverages(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "msl") 
```

### Hungtinton-Hill
How about the Hungtinton-Hill method?

```{r echo=TRUE, message=FALSE, comment=NA}
highestAverages(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "hill") 
```

### Imperiali

```{r echo=TRUE, message=FALSE, comment=NA}
highestAverages(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "imperiali") 
```

### Using thresholds

Let's assume that we have an election with 1,000 total voters in which five parties (A, B, C, D, and E) have gained 100 (10\%), 150 (15\%), 300 (30\%), 400 (40\%), and 50 (5\%) votes, respectively. In this electoral constituency, there are 3 seats up for election, and all votes cast are valid; the electoral system has a 7\% vote threshold. Meaning that parties must get at least 7\% of the total unspoiled votes cast in order to participate in the distribution of seats. 
Party *E* would then be elimiated from competition at the outset. If the d'Hondt method of seat allocation were employed, then party *C* would get 1 seat (or 33\% of the number of seats), and party *D* 2 seats (or 67\% of the seats).

```{r echo=TRUE, message=FALSE, comment=NA}

const <- c("A"=100, "B"=150,"C"=300, "D"=400, "E"=50)

highestAverages(parties=names(const), votes=const,
               seats = 3, method = "dh", threshold = 7/100) 
```

Other methods divide the votes by a mathematically derived quota, such as the Droop quota, the Hare quota (or Hamilton/Vinton), or the Imperiali quota, see next. 


## Largest Remainder Methods of Allocating Seats Proportionally

### Hare quota

```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
largestRemainders(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "hare") 
```

### Droop quota

```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
largestRemainders(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "droop") 
```

### Imperiali quota
 
```{r data-Italy, eval=FALSE, echo=TRUE, message=FALSE}

# The 1946 Italian Constituent Assembly election results: parties and unspoilt votes

Italy = data.frame(party=c("DC", "PSIUP", "PCI", "UDN", "UQ", "PRI",
                            "BNL", "PdA", "MIS", "PCd'I", "CDR",
                           "PSd'Az", "MUI", "PCS", "PDL", "FDPR"),
                   votes=c(8101004, 4758129, 4356686, 1560638,	1211956,
                           1003007, 637328, 334748, 171201, 102393,
                           97690, 78554, 71021, 51088, 40633, 21853))
```

```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
with(Italy, largestRemainders(parties=party, votes=votes, 
                seats = 556, method = "imperiali.q") )
```


## Suitable output for recycling in RMarkdown documents 

The output produced by the `highestAveragesof()` and `largestRemainders()`  functions is always a `data.frame`; therefore, it's very straightforward  to use with other aplications. For instance, I like the idea of using the output with the **knitr** package to produce publishable-quality tables, or graphs with **ggplot2**.


```{r echo=TRUE, message=FALSE, comment=NA}
mytable = highestAverages(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "dh") 

library(knitr)

kable(mytable, align=c("l","c","c"))
```



```{r echo=TRUE, message=FALSE, fig.width=4.5, fig.height=4.5, fig.align="center", fig.cap= "2014 Legislative Election in Ceara (M=42)"}

mytable = highestAverages(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "dh") 

p <- ggplot(mytable, aes(x=reorder(Party, Seats), y=Seats)) + 
  geom_bar( position="dodge", stat = "identity") +
  coord_flip() + labs(x="", y="# Seats")

p + theme_grey() 
```




# Exploratory Statistical Tests


# Plot Design

The default **ggplot2** design has its charm, in my opinion. But, very often I don't like the gray background grid, particularly when I'm preparing academic papers because I feel it distracts from the data. For example, see this **ggplot2** visualization of the following plot:

```{r eval=TRUE}
detach("package:SciencesPo")

ggplot(mtcars, aes(mpg, disp,color=factor(carb),size=hp)) + geom_point(alpha=0.7) + labs(title="Bubble Plot") + scale_size_continuous(range = c(3,10))

qplot(1:3, 1:3)
```

I rather prefer a clean layout for publication. Starting with simple layouts is better because we can add things as we need rather than taking them away. Thus, by default, the `theme_pub` prints a plot without background and minor grid lines. Also, if a legend is needed, it will appear underneath of the plot rather than on the right side.

```{r eval=TRUE}
require(SciencesPo)
qplot(1:3, 1:3)
```

There's a complete discussion of plot design in the outstanding reference [Cookbook for R](http://www.cookbook-r.com/Graphs/Legends_%28ggplot2%29/) that might be of your interest.

## Changing defaults 
If you want to change the theme for an entire session you can use `theme_set()` as in `theme_set(theme_gray())` to switch to default **ggplot2** theme for all subsequent plots. Otherwise, you may also apply themes without changing the default setup as of `plot + theme_gray()`. 

To modify general aspects of the `theme_pub()` as fontsize, font family etc:

```{r echo=FALSE, message=FALSE}
require(SciencesPo)
theme_set(theme_pub(font_size=12)) # default fontsize doesn't work well for online viewing
qplot(1:3, 1:3)
```


The default fontfamily used in the theme is "Helvetica", but it is easy to chane to another style: 
```{r echo=FALSE, message=FALSE}
require(SciencesPo)
# "Verdana", "serif" and "sans" are also high-readability fonts
theme_set(theme_pub(font_size=12, font_family = "Consolas")) 
qplot(1:3, 1:3)
```

Modify it with theme()
```{r echo=FALSE, message=FALSE}
prefs <- theme(axis.text = element_text(size=14, colour=NULL))

qplot(1:3, 1:3) + prefs
```



```{r echo=FALSE, message=FALSE}
# Modifying a theme function
themeMod <- theme_gray() +
  theme(text = element_text(family = "Times", colour = "blue", size = 14))

ggplot(mpg, aes(x = cty, y = hwy, colour = factor(cyl))) + 
   geom_point(size = 2.5)
```


You might be able to put the legend inside the plot area, using:
  
line_plot + theme(legend.justification=c(1,0), legend.position=c(1,0))

This positions the legend inside the plot area, at the bottom-right. You can also put the legend at the top or bottom of the plot using, e.g.:
  
line_plot + theme(legend.position="bottom")



```{r echo=FALSE, message=FALSE}
# Only change the 'colour' property of theme element 'text'

mytheme1 <- theme_grey() + theme(text = element_text(colour="red"))
mytheme1$text
```


```{r echo=FALSE, message=FALSE}
# Replace the 'text' element entirely
mytheme2 <- theme_grey() %+replace% theme(text = element_text(colour="red"))
mytheme2$text
```

By default, **SciencesPo** disables grid lines on the plot. In many cases, this is the cleanest and most elegant way to display the data. However, sometimes gridlines may be useful, and thus **SciencesPo** provides a simple way of adding gridlines, via the function `background_grid()`:

```{r eval=FALSE, message=FALSE}
plot.mpg + background_grid(major = "xy", minor = "none")
```

While the same result could be obtained using the function `theme()`, the function `background_grid()` makes the most commonly used option easily accessible. See the reference documentation for details.

# Generic plot annotations

Finally, the `draw_plot()` function also allows us to place graphs at arbitrary locations and at arbitrary sizes onto the canvas. This is useful for combining subplots into a layout that is not a simple grid, e.g. with one sub-plot spanning the entire width of the figure and two other figures using up half of the figure width:

```{r eval=FALSE, message=FALSE, fig.width=7, fig.height=5}

plot.iris <- ggplot(iris, aes(Sepal.Length, Sepal.Width)) + 
  geom_point() + facet_grid(. ~ Species) + stat_smooth(method = "lm") +
  background_grid(major = 'y', minor = "none") + # add thin horizontal lines 
  panel_border() # and a border around each panel
# plot.mpg and plot.diamonds were defined earlier
ggdraw() +
  draw_plot(plot.iris, 0, .5, 1, .5) +
  draw_plot(plot.mpg, 0, 0, .5, .5) +
  draw_plot_label(c("A", "B", "C"), c(0, 0, 0.5), c(1, 0.5, 0.5), size = 15)
```


The functions `background_grid()` and `panel_border()` are convenience functions defined by **SciencesPo** to save some typing when manipulating the background grid and panel border. 

```{r eval=FALSE, echo=FALSE, message=FALSE, fig.width=7, fig.height=5}
# Of course, we can also go crazy:
ggdraw() +
  #geom_rect(data = boxes, aes(xmin = x, xmax = x + .15, ymin = y, ymax = y + .15),
  #          colour = "gray60", fill = "red", alpha=.03) +
  geom_path(data = spiral, aes(x = x, y = y, colour = t), size = 6, alpha = .4) +
  draw_plot(plot.mpg, .3, .3, .4, .4) +
  draw_plot(plot.iris, 0, .7, .7, .35 ) +
  draw_plot(plot.iris, .45, .0, .6, .3 )
```

## Annotations underneath plots

The function `geom_foot()` can be used to add text as a plot footnote. To demonstrate its use, we first draw a plot, then add the footnote: 

```{r height.matters, fig.width=7, fig.height=5}
theme_set(theme_pub())

# Generating a ratio winner/opponent measure 
Presidents = transform(Presidents, 
                       height_ratio = winner.height/opponent.height) 

# Avoid missing data
Presidents <- subset(Presidents, !is.na(height_ratio))

fit=lm(winner.vote~height_ratio,data=Presidents)

mylabel=lm2eqn("Presidents","height_ratio","winner.vote")

p1 <- ggplot(Presidents, aes(x=height_ratio, y=winner.vote)) +
      geom_smooth(method=lm, colour="red", fill="gold")+
      geom_point(size = 5, alpha = .7) +
      annotate(geom = 'text', x = 1.1, y = 70, size = 5, label = mylabel, fontface = 'italic') +
      xlim(0.85,1.2) + ylim(25, 70) +
      xlab("Winner/Opponent Height Ratio") + 
      ylab("Relative Support for the Winner")
p1 

geom_foot("Draft Analysis, 2015", color = fade("brown1"))

```

